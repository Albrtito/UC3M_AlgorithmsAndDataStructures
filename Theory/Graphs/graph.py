# -*- coding: utf-8 -*-
"""graph-dictionaryWD.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1LAeO6qpKKHWzq7uCwT952r-BlIBeztl6

# Graph implementation using a Python dictionary

This implementation allows to represent any kind of graphs.
"""


class AdjacentVertex:
    """This class allows us to represent a tuple with an adjacent vertex
    and the weight associated (by default 1, for non-unweighted graphs)"""

    def __init__(self, vertex, weight=None):
        self._vertex = vertex
        self._weight = weight

    # How vertex will be written
    def __str__(self):
        if self._weight != None:
            return '(' + str(self._vertex) + ',' + str(self._weight) + ')'
        else:
            return str(self._vertex)


class Graph():
    def __init__(self, vertices: list, directed=True):
        """We use a dictionary to represent the graph
        the dictionary's keys are the vertices
        The value associated for a given key will be the list of their neighbours.
        Initially, the list of neighbours is empty
        + When creating this graph. We give to it all the vertices.
        + This implementation also works for emtpy edges.
        + The keys of the dictionary are the nodes of the graph
        """
        self._vertices = {}  # dictionary with all the vertices.
        # Think of the way vertices are given in Discrete math. It contains the
        # value and tag of the vertex. Ex: {"A"

        # Create an emtpy list for each of the keys passed in vertices (input).
        for v in vertices:
            self._vertices[v] = []
        self._directed = directed  # Bool value.

    def addEdge(self, start, end, weight=None):
        """Recibe two vertices: Start and End. And a weight for the edge"""
        # check the keys -> The nodes
        if start not in self._vertices.keys():
            print(start, ' does not exist!')
            return
        if end not in self._vertices.keys():
            print(end, ' does not exist!')
            return

        # adds to the end of the list of neighbours for start.
        # Ex: Edge between A and B. In directed: The edge starts at A and goes to B. The node A has a connection with B
        self._vertices[start].append(AdjacentVertex(end, weight))

        # when the graph is undirected. We do it as if there was a connection between A and B ,and B andA
        if not self._directed:
            # adds to the end of the list of neighbours for end
            self._vertices[end].append(AdjacentVertex(start, weight))

    def containsEdge(self, start, end):
        if start not in self._vertices.keys():
            print(start, ' does not exist!')
            return 0
        if end not in self._vertices.keys():
            print(end, ' does not exist!')
            return 0

        # we search the AdjacentVertex whose v is end
        for adj in self._vertices[start]:
            if adj._vertex == end:
                if adj._weight != None:
                    return adj._weight
                else:
                    return 1  # unweighted graphs
        return 0  # does not exist

    def removeEdge(self, start, end):
        if start not in self._vertices.keys():
            print(start, ' does not exist!')
            return
        if end not in self._vertices.keys():
            print(end, ' does not exist!')
            return

        # we must look for the adjacent AdjacentVertex (neighbour)  whose vertex is end, and then remove it
        for adj in self._vertices[start]:
            if adj._vertex == end:
                self._vertices[start].remove(adj)

        # Do the same thing done above. Because it is not directed the start and end swap.
        if self._directed == False:
            # we must also look for the AdjacentVertex (neighbour)  whose vertex is end, and then remove it
            for adj in self._vertices[end]:
                if adj._vertex == start:
                    self._vertices[end].remove(adj)

    def getAdjacents(self, vertex):
        if vertex not in self._vertices.keys():
            print(vertex, "does not exist!")
            return
        list = []
        for adjvertex in self._vertices[vertex]:
            list.append(adjvertex._vertex)
        return list

    def getOrigins(self, vertex):
        """ Return a list with  the origins values for a node. The nodes this node is refered in"""
        list = []

        # Check that the vertex exist
        if vertex not in self._vertices.keys():
            print(vertex, "does not exist!")
            return

        # Go through all the keys
        for v in self._vertices.keys():
            # Go through all the elements of each list of each key.
            for adjvertex in self._vertices[v]:
                print(adjvertex)
                if adjvertex._vertex == vertex:
                    list.append(adjvertex._vertex)
        return list

    def __str__(self):
        result = ''
        for v in self._vertices:
            result += '\n' + str(v) + ':'
            for adj in self._vertices[v]:
                result += str(adj) + "  "
        return result


"""We use the implementation to represent an undirected graph without weights :


<img src='https://computersciencesource.files.wordpress.com/2010/05/dfs_1.png' width='35%'/>
"""
if __name__ == '__main__':
    labels = ['A', 'B', 'C', 'D', 'E']
    g = Graph(labels, False)
    g.addEdge('A', 'B')  # A:0, B:1
    g.addEdge('A', 'C')  # A:0, C:2
    g.addEdge('A', 'E')  # A:0, E:5
    g.addEdge('B', 'D')  # B:1, D:4
    g.addEdge('B', 'E')  # C:2, B:1
    # g.addEdge('A','H',8)

    print(g)

    """Now, we use the implementation to represent this graph: 

    <img src='https://upload.wikimedia.org/wikipedia/commons/thumb/b/bc/CPT-Graphs-directed-weighted-ex1.svg/722px-CPT-Graphs-directed-weighted-ex1.svg.png' width='25%'/>
    """

    labels = ['A', 'B', 'C', 'D', 'E']

    g = Graph(labels)

    # Now, we add the edges
    g.addEdge('A', 'C', 12)  # A->(12)C
    g.addEdge('A', 'D', 60)  # A->(60)D
    g.addEdge('B', 'A', 10)  # B->(10)A
    g.addEdge('C', 'B', 20)  # C->(20)B
    g.addEdge('C', 'D', 32)  # C->(32)D
    g.addEdge('E', 'A', 7)  # E->(7)A

    print(g)

    print(g.containsEdge('C', 'B'))

    print(g.containsEdge('B', 'C'))
    g.removeEdge('C', 'B')
    print(g)
